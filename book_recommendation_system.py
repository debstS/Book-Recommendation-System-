# -*- coding: utf-8 -*-
"""Book Recommendation System.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XMDiCfsMdL86W1Cdty53JbkP1LXpOg4d

# Book Recommendation Project Workflow



*   This project aims to build a basic Book Recommendation System using the KNN classifier approach

*   The recommendations will be based on-

![images.jpg](data:image/jpeg;base64,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)
"""

import pandas as pd
import numpy as np

# for data visualisation
import matplotlib.pyplot as plt
import seaborn as sns

# for interactive plots
import ipywidgets
from ipywidgets import interact
from ipywidgets import interact_manual

df = pd.read_csv('/content/books.csv', error_bad_lines = False)

"""# Descriptive statistics"""

df.head()

df.shape

df.columns

df.columns = df.columns.str.strip()
df.columns

df.dtypes

df.describe()

df.describe(include='object')

# Check null values

df.isnull()

df.isnull().sum()

#to check duplicate data
df.duplicated().any()

df.info()

"""# **Feature Engineering**



*   To extract important features  
*   Reducing the size of Features
*   Creating new features from the existing ones





"""

df.columns

df["isbn"].nunique()

df.isbn13.nunique()

df.drop(['bookID','isbn','isbn13'], axis = 1, inplace = True)

df.columns

#Checking the publication date to extract Publication Year

df['publication_date']

df['year'] = df['publication_date'].str.split('/')
df['year'] = df['year'].apply(lambda x: x[2])

df.head()

df.dtypes

# Change year column's data type from 'Object' to 'Int'

df['year'] = df['year'].astype('int')

df.dtypes

#To check Min and MAx year of publication

df['year'].min()

df['year'].max()

df.columns

"""#**Exploratory Data Analysis**"""

# To fetch the details like which book was published in 2020, by which author, language code, publisher, rating, etc. This is equivalent to SQL retrieval from a table

df[df['year'] == 2020][['title','authors','average_rating','language_code','publisher']]

#to check which book was released, and how many books were released - YEAR wise

df.groupby(['year'])['title'].agg('count').sort_values(ascending = False).head(20)

# To check which is the top author who published most books --iloc=10 because we want TOP 10 most published authors

#below line just to adjust the font size to correct the author name-
plt.figure(figsize = (20,10))

sns.countplot(x = 'authors', data = df, order = df['authors'].value_counts().iloc[:10].index)
plt.title('Top 10 authors with maximum books published')
plt.xticks(fontsize = 12)
plt.show()

# To check count of books published language-wise

df.language_code.value_counts()

#To check ratings, text review, and average rating of books Language-wise

df.groupby(['language_code']) [['average_rating','ratings_count','text_reviews_count']].agg('mean').style.background_gradient(cmap = 'Wistia')

book = df['title'].value_counts()[:20]  #to get top 20
book

## To check most frequently occurring book in our data


#to get the book name font visible
plt.figure(figsize = (20, 6))

book = df['title'].value_counts()[:20]  #to get top 20

#we want now to know the index and no of times a book occurs from the data from the top 20 list

sns.barplot(x = book.index, y = book, palette = 'winter_r')

plt.title('Most frequently occurring Book in the data')
plt.xlabel('Number of Occurrence')
plt.ylabel('Books')

#to show the book name clearly--adding rotation below
plt.xticks(rotation=75, fontsize = 13)


plt.show()

"""#To Plot-

*   What is average rating?
*   Which book has the avg rating
*   Which book has the highest review?


"""

sns.distplot(df['average_rating'])
plt.show()

# To check the highest-rated book based on Author, Language

df[df['average_rating'] == df.average_rating.max()][['title','authors','language_code','publisher']]

# To check which is the highest published publisher? And TOP 10 or 20 publisher

plt.figure(figsize = (20,10))
publisher = df['publisher'].value_counts()[:20] # for TOP 20 publishers
sns.barplot(x = publisher.index, y = publisher, palette = 'winter_r')
plt.title("Publishers")
plt.xlabel('Number of Occurrence')
plt.ylabel('Publishers')
plt.xticks(rotation = 75, fontsize = 13)

plt.show()



"""#Recommendation System Design

*   Recommend books Based on Publishers
*   Recommend books Based on Authors
*   Recommend books Based on Language

## Recommend books - Based on publishers
"""

# FUNCTION for -Recommend books Based on publishers


def recommend_books_by_publishers(x):
  a = df[df['publisher'] == x][['title', 'average_rating']]
  a = a.sort_values(by = 'average_rating', ascending = False) #to sort the recommended books by their avg_rating
  return a.head(10)

# To recommend books based on publisher passed as argument 'x'

recommend_books_by_publishers ('Vintage')

# To recommend books based on publisher passed as argument 'x'

recommend_books_by_publishers ('Penguin')

"""### To recommend books based on drop-down from the list of Publishers instead of passing it manually everytime

"""

@interact
def recommend_books_by_publishers(publisher_name = list(df['publisher'].value_counts().index)):
    a = df[df['publisher'] == publisher_name][['title', 'average_rating']]
    a = a.sort_values(by = 'average_rating', ascending = False)
    return a.head(10)

"""## Recommend books - Based on Authors



"""

@interact
def recommend_books_by_authors(author_name = list(df['authors'].value_counts().index)):
    a = df[df['authors'] == author_name][['title', 'average_rating']]
    a = a.sort_values(by = 'average_rating', ascending = False)
    return a.head(10)

df.columns

"""## Recommend books - Based on Language"""

@interact
def recommend_books_by_language(language_name = list(df['language_code'].value_counts().index)):
    a = df[df['language_code'] == language_name][['title', 'average_rating']]
    a = a.sort_values(by = 'average_rating', ascending = False)
    return a.head(10)

"""#**Data Preprocessing**


*  To change the categorical data into numerical format
*  Change the avg_rating floating point number into same format




"""

# to label Rating

def num_to_obj(x):
    if x >0 and x <=1:
        return "between 0 and 1"
    if x > 1 and x <= 2:
        return "between 1 and 2"
    if x > 2 and x <=3:
        return "between 2 and 3"
    if x >3 and x<=4:
        return "between 3 and 4"
    if x >4 and x<=5:
        return "between 4 and 5"
df['rating_obj'] = df['average_rating'].apply(num_to_obj)

# to check object values between
df.rating_obj.value_counts()

"""# Apply One-hot encoding for the categorical object columns"""

df['rating_obj'].value_counts()

rating_df = pd.get_dummies(df['rating_obj'])
rating_df.head()

df.columns

# to One-hot encode language column

language_df = pd.get_dummies(df['language_code'])
language_df.head()

# to bring both one-hot encoded columns in one dataframe

features = pd.concat([rating_df,language_df, df['average_rating'],
                    df['ratings_count'], df['title']], axis = 1)
features.set_index('title', inplace= True)
features.head()

"""## Perform Standardization to bring all data on same scale to avoid a biased model"""

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler()
features_scaled = scaler.fit_transform(features)

features_scaled

"""# Model Creation


*  Use of K-nearest neighbours to classify a new data point


"""

from sklearn import neighbors  #to import and apply KNN

model = neighbors.NearestNeighbors(n_neighbors=5, algorithm = 'ball_tree',
                                  metric = 'euclidean')
model.fit(features_scaled)
dist, idlist = model.kneighbors(features_scaled)

df['title'].value_counts()

@interact
def BookRecommender(book_name = list(df['title'].value_counts().index)):
    book_list_name = []
    book_id = df[df['title'] == book_name].index
    book_id = book_id[0]
    for newid in idlist[book_id]:
        book_list_name.append(df.iloc[newid].title)
    return book_list_name